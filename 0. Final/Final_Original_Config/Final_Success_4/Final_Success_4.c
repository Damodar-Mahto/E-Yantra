/*
 * Final_success_1.c
 * Created: 01-03-2017 17:49:30
 * Author: Damodar Mahto
 * This is my final code including all the sensors and algorithm.
 * This program is used to detect the nodes,obstacles while traversing through the grid, turns around when obstacle is detected 
   and sounds the buzzer when node,obstacle is detected and also sends the data to pc via X_BEE.
*/
/**************************************************************** Header Files ******************************************************************/
#define F_CPU 14745600
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <math.h>        //included to support power function
#include <stdlib.h>
#include "i2c_lib.h"
#include "i2c_lib.c"
#include "lcd.h"
/***************************************************** Function Definitions ************************************************************/
void port_init();
void timer5_init();
void init_devices (void);
void buzzer_beep();
void buzzer_beep_long();
unsigned char ADC_Conversion(unsigned char);
void print_sensor(char row, char coloumn,unsigned char channel);
void velocity(unsigned char, unsigned char);
void stop_bot();
void sensor_refresh();
void check_status(STAT status);
void send_to_pc();
void node_detector();

/********************************************************************** Global Variables **************************************************************/
unsigned int node_count = 0; //to count the no of node detected
unsigned int line_no= 1;     //to keep track of the line no
unsigned char flag_node = 0; //to check the presence of nodes
unsigned char run = 0;       //to count the scanning run
unsigned char flag_Shape = 0;//to check the shape between the nodes
unsigned char flag_S1 = 0;   //to check shape S1
unsigned char flag_S2 = 0;   //to check shape S2
unsigned char flag_S3 = 0;   //to check shape S3
unsigned char flag_S4 = 0;   //to check shape S4
unsigned int quotient = 0;   //to store quotient of division processes
unsigned int rmnder = 0;     //to store remainder of division processes
unsigned char obstacle_array[5][5];  //to store the location of the obstacles in arena
unsigned char priority=0;            //to choose priority when obstacle is detected
unsigned char path_direction='0';      //to store the path direction before the present node
unsigned char shape_type='0';          //to store the type of shape detected between 
unsigned char flag_left_object = 0;   //to check the left object
unsigned char flag_right_object = 0;  //to check the right object
unsigned left_object_type='0';         //to store the type of left object
unsigned right_object_type='0';        //to store the type of right object
volatile unsigned obstacle_found='0';           //to check the presence of obstacle in the previous path
volatile unsigned char pathL = 0;    //to count left path length
volatile unsigned char pathR = 0;    //to count right path length
volatile unsigned char ADC_Value;    //to store the ADC conversion value
volatile unsigned char L=0;          //to store ADC value of left white line sensor.  
volatile unsigned char C=0;          //to store ADC value of center white line sensor. 
volatile unsigned char R=0;          //to store ADC value of right white line sensor.
volatile unsigned char IR1=0;        //to store ADC value of IR proximity sensor 3. 
volatile unsigned char IR2=0;        //to store ADC value of IR proximity sensor 3. 
volatile unsigned char IR3=0;        //to store ADC value of IR proximity sensor 3. 
volatile unsigned char IR4=0;        //to store ADC value of IR proximity sensor 3.  
volatile unsigned char IR5=0;        //to store ADC value of IR proximity sensor 3. 
volatile unsigned char SHARP1=0;     //to store ADC value of sharp sensor 1.
volatile unsigned char SHARP5=0;     //to store ADC value of sharp sensor 5. 
volatile unsigned long int ShaftCountLeft = 0; //to keep track of left position encoder
volatile unsigned long int ShaftCountRight = 0; //to keep track of right position encoder
volatile unsigned int Degrees;        //to accept angle in degrees for turning
volatile unsigned char colour=0;	  //to store the type of colour detected
volatile unsigned char conf=0;		  // to differentiate between node and obstacle
volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;     // variable to store the pulse count when read_green function is called

/********************************************************************** I2C  addresses    *************************************************************************/
#define DEV_ADD	 0x68<<1	// device address, last bit corresponds to R/W
#define WHO_AM_I  0x75		//internal register in which the device id is stored
#define DEV_ID_VAL 0x68		//value of default device id which is stored in WHO_AM_I register
#define X_ACC  0x3B		    //internal data register where  acc_x data is stored
#define Z_GYRO	0x47		//internal data register where  gyro_z data is stored
#define INIT_REG 0x6B		//an internal initializing register(power, sleep, e.t.c.)
#define INIT_REG_ACC 0x1C   //an internal initializing register for accelerometer
#define INIT_REG_GYRO 0x1B   //an internal initializing register for accelerometer
#define INIT_VAL 0x00       //Initialization value of the initialization register
UINT8 devid;                //stores the device id obtaind from GY-87
INT8 acc_data_x[2];         //to store the acc. x-axis data
INT8 gyro_data_z[2];        //to store the gyro. z-axis data

int acc_x=0;                //to store the acc reading
int gyro_y=0;				//to store the gyro reading y
int gyro_z=0;				//to store the gyro reading z
float force_x=0;            //acc in x direction
float rotation_y=0;         //rotation in y dir
float rotation_z=0;         //rotation in z dir

/************************************************************************** PORT Initialization **********************************************************************/
//Function to initialize Buzzer
void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
}

void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
}

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 5 pin as input
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
}

//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
 PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
}

//ADC pin configuration
void adc_pin_config (void)
{
 DDRF = 0x00; 
 PORTF = 0x00;
 DDRK = 0x00;
 PORTK = 0x00;
}

//Function to configure ports to enable robot's motion
void motion_pin_config (void) 
{
 DDRA = DDRA | 0x0F;
 PORTA = PORTA & 0xF0;
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
}

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xF7;   //set PD3 as input for color sensor output
	PORTD = PORTD | 0x08;  //Enable internal pull-up for PD3 pin
}

//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
	DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
	PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
}

//Function to Initialize PORTS
void port_init()
{
	buzzer_pin_config ();
	lcd_port_config();
	adc_pin_config();
	motion_pin_config();	
	left_encoder_pin_config();   //left encoder pin config
	right_encoder_pin_config();  //right encoder pin config
    color_sensor_pin_config(); //color sensor pin configuration
	servo1_pin_config();       //Configure PORTB 5 pin for servo motor 1 operation 
}

/****************************************************** Other Initializations ***************************************************************************/
void uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
	UCSR0A = 0x00;
	UCSR0C = 0x06;
	// UBRR0L = 0x47; //11059200 Hz
	UBRR0L = 0x5F; // 14745600 Hzset baud rate lo
	UBRR0H = 0x00;       //set baud rate hi
	UCSR0B = 0x18;
}

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
	sei();   // Enables the global interrupt
}

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
	sei();   // Enables the global interrupt
}

// Timer 5 initialized in PWM mode for velocity control
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
}

void timer1_init(void)
{
 TCCR1B = 0x00; //stop
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
 ICR1H  = 0x03;	
 ICR1L  = 0xFF;
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
}

void adc_init()
{
	ADCSRA = 0x00;
	ADCSRB = 0x00;		//MUX5 = 0
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
	ACSR = 0x80;
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
}

void color_sensor_pin_interrupt_init(void) //Interrupt 3 enable
{
	cli(); //Clears the global interrupt
	EICRA = EICRA | 0x80; // INT3 is set to trigger with falling edge
	EICRB = EICRB | 0x00;
	EIMSK = EIMSK | 0x08; // Unmask Interrupt INT3 for color sensor
	sei(); // Enables the global interrupt
}

void init_devices (void)
{
	cli();                  //Clears the global interrupts
	port_init();
	uart0_init();
	left_position_encoder_interrupt_init();
	right_position_encoder_interrupt_init();
	timer5_init();
	timer1_init();
	adc_init();
	color_sensor_pin_interrupt_init();
	sei();                  //Enables the global interrupts
}

/******************************* ISR *****************************************/

//ISR for right position encoder
ISR(INT5_vect)
{
	ShaftCountRight++;  //increment right shaft position count
	pathR++;
}


//ISR for left position encoder
ISR(INT4_vect)
{
	ShaftCountLeft++;  //increment left shaft position count
	pathL++;
}

//ISR for color sensor
ISR(INT3_vect)
{
	pulse++; //increment on receiving pulse from the color sensor
}

/******************************* ********************************** Functions *********************************************************/
// Function to beep buzzer for short time.
void buzzer_beep (void) 
{
	PORTC =PORTC | 0x08;    //turns on the buzzer PC3=1
	_delay_ms(50);
	PORTC =PORTC & 0xF7;    //turns off the buzzer PC3=0
}

//Function to beep buzzer for 10s and mar the end of scanning.
void buzzer_beep_long(void)
{
	PORTC =PORTC | 0x08;    //turns on the buzzer PC3=1
	_delay_loop_2(10);
}

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
	OCR1AL = (unsigned char) PositionPanServo;
}

void servo_1_free (void) //makes servo 1 free rotating for saving power
{
	OCR1AH = 0x03;
	OCR1AL = 0xFF; //Servo 1 off
}

//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch) 
{
	unsigned char a;
	if(Ch>7)
	{
		ADCSRB = 0x08;
	}
	Ch = Ch & 0x07;  			
	ADMUX= 0x20| Ch;	   		
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
	a=ADCH;
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
	ADCSRB = 0x00;
	return a;
}

//Function To Print Sensor Values At Desired Row And Column Location on LCD
void print_sensor(char row, char coloumn,unsigned char channel)
{
	ADC_Value = ADC_Conversion(channel);
	lcd_print(row, coloumn, ADC_Value, 3);
}

//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
	OCR5BL = (unsigned char)right_motor;
}

//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
}

void forward (void)
{
	motion_set (0x06);
}

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
}

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
}

void back (void)
{
	motion_set (0x09);
}

void stop_bot(void)
{
  motion_set (0x00);
}

//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
	ShaftCountRight = 0;
	ShaftCountLeft = 0;

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) || (ShaftCountLeft >= ReqdShaftCountInt))
		break;
	}
	stop_bot(); //Stop robot
}

void left_degrees(unsigned int Degrees)
{
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
	angle_rotate(Degrees);
}

void right_degrees(unsigned int Degrees)
{
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right(); //Turn right
	angle_rotate(Degrees);
}

//Function used for moving robot forward by specified length
void linear_distance_mm(unsigned int DistanceInMM)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
	
	ShaftCountRight = 0;
	ShaftCountLeft = 0;
	while(1)
	{
		if((ShaftCountRight > ReqdShaftCountInt)||(ShaftCountLeft > ReqdShaftCountInt))
		{
			break;
		}
	}
	//stop(); //Stop robot
}

void forward_mm(unsigned int DistanceInMM)
{
	forward();
	linear_distance_mm(DistanceInMM);
}

void back_mm(unsigned int DistanceInMM)
{
	back();
	linear_distance_mm(DistanceInMM);
}

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD & 0x7F; //set S3 low
}

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD & 0x7F; //set S3 Low
}

//Color Sensing Scaling - 20% 
void color_sensor_scaling()		
{
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
}

void red_read(void) // function to select red filter 
{
	filter_red(); //select red filter
	pulse=0;
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  
}

void green_read(void) // function to select green filter 
{
	filter_green(); //select green filter
	pulse=0; 
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse; 
}

void blue_read(void) // function to select blue filter 
{
	filter_blue(); //select blue filter
	pulse=0; 
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  
}


void sensor_refresh()
{
	L= ADC_Conversion(3);	//Getting data of White Line Sensors
	C= ADC_Conversion(2);	
	
	R= ADC_Conversion(1);	
	
	IR1=ADC_Conversion(4);
	IR3=ADC_Conversion(6);  //Getting data of IR proximity Sensors
	IR5=ADC_Conversion(8);
	
	SHARP1=ADC_Conversion(9); //Getting data of Sharp Sensors
	SHARP5=ADC_Conversion(13); 
}

//function to read the sensor values from GY-87 module
void I2C_read()
{
	i2c_read_multi_byte(DEV_ADD, X_ACC,2,acc_data_x);   //reading 2 data bytes and storing it into acc_data[2] array
	//i2c_read_multi_byte(DEV_ADD, Y_GYRO,2,gyro_data_Y);   //reading 4 data bytes and storing it into gyro_data[2] array
	i2c_read_multi_byte(DEV_ADD, Z_GYRO,2,gyro_data_z);   //reading 4 data bytes and storing it into gyro_data[2] array
    
	acc_x = acc_data_x[0];
    acc_x = (acc_x << 8);
    acc_x += acc_data_x[1];
    force_x = acc_x;
  
    /*gyro_z = gyro_data_z[0];
    gyro_z = (gyro_z << 8);
    gyro_z += gyro_data_z[1];
    rotation_z = gyro_z/131;*/
	
	
    gyro_z = gyro_data_z[0];
    gyro_z = (gyro_z << 8);
    gyro_z += gyro_data_z[1];
    rotation_z = gyro_z/131;
}

//function to identify the colour of the object
unsigned char colour_detector()
{
	red_read(); //read the pulse count when red filter is selected
	green_read(); //read the pulse count when green filter is selected
	blue_read(); //read the pulse count when blue filter is selected
	
	if(red>450 && green>450 && blue>450)
	{
		if(red>green && red>blue)
		{
			return 'R';
		}
		else if(green>red && green>blue)
		{
			return 'G';
		}
		else if(blue>green && blue>red)
		{
			return 'B';
		}
	}
	else
	{
		return '0';
	}
}

//function to detect the type of object
void object_detector()  
{
	if(flag_left_object==1)                     //when object is present only in left
	{
		servo_1(20);
		_delay_ms(1000);
		left_object_type=colour_detector();                     //scanning left side
		
		servo_1(80);
		_delay_ms(500);                        //repositioning the servo at default angle
		servo_1_free();
	}
	else if(flag_right_object==1)                     //when object is present only in right
	{
		servo_1(190);
		_delay_ms(1200);
		right_object_type=colour_detector();                     //scanning right side
		
		servo_1(80);
		_delay_ms(700);                        //repositioning the servo at default angle
		servo_1_free();
	}
}

void tunnel_traveller()             //this function is used to navigate through, when tunnel is detected.
{
	sensor_refresh();
	while((L < 0x17) && (C < 0x17) && (R < 0x17))
	{
		if(IR1>30 && IR5>30)
		{
			velocity(140,140);
			forward_mm(6);
		}
		if(IR1<30)
		{
			right_degrees(6);  //soft right
			velocity(140,140);
			forward_mm(10);
		}
		if(IR5<30)
		{
			left_degrees(6);  //soft left
			velocity(140,140);
			forward_mm(10);
		}
		sensor_refresh();
	}
	servo_1(70);
	_delay_ms(100);
	servo_1_free();
	node_detector();
}

//to check the status of the I2C communication
void check_status(STAT status)
{
	if(status != OK)
	{
		lcd_cursor(1,2);
		_delay_ms(50);
		lcd_string("Status Not OK");
		_delay_ms(50);
		while(1);		//error in transmission using i2c
	}
}
/*************************************************************** Algorithm ********************************************************/

void right_turn()   //to turn 90 degree right
{
	velocity(200,200);
	forward_mm(30);
	right_degrees(95);
	//forward_mm(10);
	velocity(170,170);
}

void left_turn()   //to turn 90 degree left
{
	velocity(200,200);
	forward_mm(30);
	left_degrees(95);
	//forward_mm(10);
	velocity(170,170);
}

void move_forward()       //to move forward until node is detected.
{
	sensor_refresh();
	while(!((L>0x17 && C>0x17 && R>0x17) || (L<0x17 && C>0x17 && R>0x17) || (L>0x17 && C>0x17 && R<0x17) || (IR3 < 0x30)))
	{
		if((L<0x17 && C>0x17 && R<0x17))        // 010
		{
			forward_mm(5);
			velocity(170,170);
		}
		else if((L<0x17 && C<0x17 && R>0x17))   // 001 0r 011
		{
			right_degrees(6);  //soft right}
			velocity(150,150);
		}
	
		else if((L>0x17 && C<0x17 && R<0x17))   // 100
		{
			left_degrees(6);    //soft left
			velocity(150,150);
		}
		else
		{
			forward_mm(10);
			velocity(170,170);
		}
		sensor_refresh();
	}
	if (IR3 < 0x30)
	{
		obstacle_found='1';
	}
	buzzer_beep();	
}

unsigned char direction_calculator()      //to calculate the direction in the path previous to current node
{
	rmnder=node_count % 6;
	if (run == 1)
	{
		if(node_count == 0)
		{
			return 'N';
		}
		else if(rmnder == 0)
		{
			return 'E';
		}
		else if((line_no == 1) || (line_no == 3) || (line_no == 5))
		{
			return 'N';
		}
		else if((line_no == 2) || (line_no == 4) || (line_no == 6))
		{
			return 'S';
		}
	}
	else if(run == 2)
	{
		if(node_count == 0)
		{
			return 'W';
		}
		if(rmnder == 0)
		{
			return 'N';
		}
		else if((line_no == 1) || (line_no == 3) || (line_no == 5))
		{
			return 'W';
		}
		else if((line_no == 2) || (line_no == 4) || (line_no == 6))
		{
			return 'E';
		}
	}
}

void obstacle_update()        //to update the obstacle count
{
	rmnder=node_count % 6;
	if((line_no == 3) || (line_no == 5))
	{
		obstacle_array[line_no - 1][rmnder - 1]=1;
		obstacle_array[line_no - 1][rmnder]=1;
	}
	else if((line_no == 2) || (line_no == 4))
	{
		obstacle_array[line_no - 1][5 - rmnder]=1;
		obstacle_array[line_no - 1][4 - rmnder]=1;
	}
}

unsigned char obstacle_check()
{
	rmnder=node_count % 6;
	if((line_no == 3) || (line_no == 5))
	{
		if(obstacle_array[line_no - 2][rmnder - 1] == 1)
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}
	else if((line_no == 2) || (line_no == 4) || (line_no == 6))
	{
		if(obstacle_array[line_no - 2][5 - rmnder] == 1)
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}
}

void default_path()  //default path chosen by bot when obstacle is detected
{
	back_mm(80);
	stop_bot();
	_delay_ms(100);
	right_turn();
	move_forward();
	forward_mm(30);
	left_turn();
	move_forward();
	forward_mm(20);
	send_to_pc();
	_delay_ms(1000);
	move_forward();
	forward_mm(20);
	left_turn();
	move_forward();
	forward_mm(30);
	left_turn();
	move_forward();
	stop_bot();
	left_degrees(190);
	back_mm(90);
	node_count++;
}

void alternate_path()  //alternate path chosen by bot when obstacle is detected
{
	back_mm(80);
	stop_bot();
	_delay_ms(100);
	left_turn();
	move_forward();
	forward_mm(30);
	right_turn();
	move_forward();
	forward_mm(20);
	send_to_pc();
	_delay_ms(1000);
	move_forward();
	forward_mm(30);
	right_turn();
	move_forward();
	forward_mm(30);
	right_turn();
	move_forward();
	stop_bot();
	left_degrees(190);
	back_mm(90);
	node_count++;
}

//this function will be used, when obstacle is detected
void obstacle_detector()
{
	buzzer_beep();
	obstacle_update();
	obstacle_found='1';
	path_direction=direction_calculator();
	rmnder=node_count % 6;
	priority=obstacle_check();
	if((line_no == 2) || (line_no == 4))    //when obstacle is in even line numbers
	{
		if (priority == 1)
		{
			alternate_path();
		}
		else
		{
			default_path();
		}
		
	}
	else if((line_no == 3) || (line_no == 5)) 
	{
		if (priority == 1)
		{
			default_path();
		}
		else
		{
			alternate_path();
		}
		
	}
	send_to_pc();
	obstacle_found='0';
	stop_bot();
	_delay_ms(2000);
}


//this function will be used, when node is detected
void node_detector()
{
	buzzer_beep();
	path_direction = direction_calculator();
	node_count++;
	if (node_count == 11 || node_count == 27 || (run==2 && node_count==28))
	{
		stop_bot();
		_delay_ms(2000);
	}
	if (node_count > 1)
	{
		send_to_pc();
	}
	
	flag_left_object=0;
	flag_right_object=0;
	left_object_type='0';
	right_object_type='0';
	obstacle_found='0';
	pathL=0;
	pathR=0;
	flag_Shape=0;
	shape_type='0';
	
	
	
	if((node_count == 36) && (run == 1))   //end of run=1,run=2 starts 
	{
		stop_bot();
		_delay_ms(2000);
		right_turn();
		buzzer_beep();
		run=2;
		node_count=1;
		line_no=1;
		for (int i=0; i < 5; i++)
		{
			for(int j=0; j < 5; j++)
			{
				obstacle_array[i][j]=0;
			}
		}
    }
	else if((node_count == 36) && (run == 2))  //finished scanning the arena, turn on buzzer and stop permanently
	{
		velocity(0,0);
		stop_bot();
		while(1)
		{
			buzzer_beep_long();
		}
		
	}
	
	quotient = node_count / 6;
	rmnder = node_count % 6;
	
	if(quotient == 1 || quotient == 3 || quotient == 5)   //at end of north and begining of south direction
	{
		if((rmnder == 0) || (rmnder == 1))
		{
			right_turn();
			pathL=18;
			pathR=18;
		}
		if(rmnder == 1)
		{
			line_no++;
		}
	}
	
	else if(quotient == 2 || quotient == 4)          //at end of south and begining of north direction
	{
		if((rmnder == 0) || (rmnder == 1))
		{
			left_turn();
			pathL=18;
			pathR=18;
			
		}
		if(rmnder == 1)
		{
			line_no++;
		}
	}
}


/************************************************************ Send to PC ************************************************************/

//function to send the data to pc using UART0
void send_to_pc()
{
	
	stop_bot();
	velocity(0,0);
	UDR0=path_direction;
	_delay_ms(100);
	UDR0=obstacle_found;
	_delay_ms(100);
	UDR0=left_object_type;
	_delay_ms(100);
	UDR0=right_object_type;
	_delay_ms(100);
	UDR0=shape_type;
	_delay_ms(100);
	UDR0=' ';
	UDR0=' ';
	_delay_ms(1000);
	velocity(170,170);
	forward_mm(10);
}


/*************************************************************** Main Function ************************************************/
int main()
{
	init_devices();
	i2c_init();
	lcd_set_4bit();
	lcd_init();
	color_sensor_scaling();
	
	servo_1(70);
	_delay_ms(200);                        //repositioning the servo at default angle(80 degrees)
	servo_1_free();
	
	//I2C device id check
	check_status(i2c_getbyte(DEV_ADD, WHO_AM_I,&devid));
	if(devid != DEV_ID_VAL)
	{
		lcd_cursor(1,2);
		_delay_ms(50);
		lcd_string("Wrng Dev ID");
		_delay_ms(50);
		while(1);			//Invalid Device id
	}
	check_status(i2c_sendbyte(DEV_ADD, INIT_REG, INIT_VAL)); //initializing the device when device id is correct.
	check_status(i2c_sendbyte(DEV_ADD, INIT_REG_ACC, INIT_VAL)); //initializing the device when device id is correct.
	check_status(i2c_sendbyte(DEV_ADD, INIT_REG_GYRO, INIT_VAL)); //initializing the device when device id is correct.
	
	run=1;
	while(1)
	{
        sensor_refresh();        //refreshes the ADC values of the sensors.
  
		if((L>0x17 && C>0x17 && R>0x17)||(L<0x17 && C>0x17 && R>0x17)||(L>0x17 && C>0x17 && R<0x17)) //|| (pathL > 76)|| (pathR > 76))   //node detection
		{
			if(flag_node==0)
			{
				node_detector();
				flag_node=1;
			}
			
		}
		if((pathL > 20) || (pathR > 20))
		{
			flag_node=0;
		}
		
		if(IR3 < 0x30)            //condition for obstacle detection
		{
			stop_bot();
			_delay_ms(200);
			obstacle_detector();     
		}
		
		if ((SHARP1 > 100 && SHARP1 < 160) && (flag_left_object==0) && (pathL > 25 && pathL < 40))   //when left object is detected.
		{
			flag_left_object=1;
			IR1=ADC_Conversion(4);
			if(IR1 < 147)
			{
				stop_bot();
				object_detector();
				flag_left_object=2;
				forward();
				velocity(140,140);
			}		
		}
		SHARP5=ADC_Conversion(13); 
		if ((SHARP5 > 48 && SHARP5 < 100) && (flag_right_object==0) && (pathR > 25 && pathR < 40))   //when right object is detected
		{
			flag_right_object=1;
			IR5=ADC_Conversion(8);
			if (IR5 < 152)
			{
				stop_bot();
				object_detector();
				flag_right_object=2;
				forward();
				velocity(140,140);
			}
			
		}
		if((flag_S4==0) && (flag_Shape == 0) && (IR1<100 && IR5<100) && (pathL > 2 && pathL < 60))    //tunnel detection
		{
			flag_S4=1;
			flag_Shape=1;
			shape_type='4';
			buzzer_beep();
			servo_1(95);
			_delay_ms(100);
			servo_1_free();
			tunnel_traveller();
		}
		
        // line follower
		sensor_refresh();
	L1:	if((L<0x17 && C>0x17 && R<0x17))        // 010 
		{
			forward_mm(5);
			velocity(170,170);	
		}
		else if((L<0x17 && C<0x17 && R>0x17))   // 001 0r 011
		{
			 right_degrees(6);  //soft right}
			 velocity(150,150);
			 C=ADC_Conversion(2);
			 if(C>0x17)
			 goto L1;
		}
		
		else if((L>0x17 && C<0x17 && R<0x17))   // 100
		{
			 left_degrees(6);    //soft left
			 velocity(150,150);
			 C=ADC_Conversion(2);  
			  if(C>0x17)
			  goto L1;
		}
		else
		{
			forward_mm(10);
			velocity(170,170);
			sensor_refresh();
		}
		
		I2C_read();              //reads the I2C value
		
		if((flag_S1==0) && (flag_Shape == 0) && ( rotation_z > 30 && rotation_z < 50 ) && (pathR > 18) && (node_count == 32))      //curve detection
		{
			flag_S1=1;
			flag_Shape=1;
			buzzer_beep();
			shape_type='1';
		}
		else if((flag_S2==0) && (flag_Shape == 0) && ( force_x > 3000 && force_x < 4000 ) && (pathR > 20 && pathR < 30) && (node_count == 10))    //bigger hump detector
		{
			flag_S2=1;
			flag_Shape=1;
			buzzer_beep();
			shape_type='2';
		}
		else if((flag_S3==0) && (flag_Shape == 0) && ( force_x > 700 && force_x < 1500 ) && (pathR > 20 && pathR < 30) && (node_count == 26))     //smaller hump detector
		{
			flag_S3=1;
			flag_Shape=1;
			buzzer_beep();
			shape_type='3';                    
		}		
	}
}

/********************************************************************* The End *******************************************************/
